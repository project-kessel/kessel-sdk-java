// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: buf/validate/validate.proto
// Protobuf Java Version: 4.32.0

package build.buf.validate;

@com.google.protobuf.Generated
public interface StringRulesOrBuilder extends
    // @@protoc_insertion_point(interface_extends:buf.validate.StringRules)
    com.google.protobuf.GeneratedMessage.
        ExtendableMessageOrBuilder<StringRules> {

  /**
   * <pre>
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   *
   * ```proto
   * message MyString {
   * // value must equal `hello`
   * string value = 1 [(buf.validate.field).string.const = "hello"];
   * }
   * ```
   * </pre>
   *
   * <code>optional string const = 1 [json_name = "const", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the const field is set.
   */
  boolean hasConst();
  /**
   * <pre>
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   *
   * ```proto
   * message MyString {
   * // value must equal `hello`
   * string value = 1 [(buf.validate.field).string.const = "hello"];
   * }
   * ```
   * </pre>
   *
   * <code>optional string const = 1 [json_name = "const", (.buf.validate.predefined) = { ... }</code>
   * @return The const.
   */
  java.lang.String getConst();
  /**
   * <pre>
   * `const` requires the field value to exactly match the specified value. If
   * the field value doesn't match, an error message is generated.
   *
   * ```proto
   * message MyString {
   * // value must equal `hello`
   * string value = 1 [(buf.validate.field).string.const = "hello"];
   * }
   * ```
   * </pre>
   *
   * <code>optional string const = 1 [json_name = "const", (.buf.validate.predefined) = { ... }</code>
   * @return The bytes for const.
   */
  com.google.protobuf.ByteString
      getConstBytes();

  /**
   * <pre>
   * `len` dictates that the field value must have the specified
   * number of characters (Unicode code points), which may differ from the number
   * of bytes in the string. If the field value does not meet the specified
   * length, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value length must be 5 characters
   * string value = 1 [(buf.validate.field).string.len = 5];
   * }
   * ```
   * </pre>
   *
   * <code>optional uint64 len = 19 [json_name = "len", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the len field is set.
   */
  boolean hasLen();
  /**
   * <pre>
   * `len` dictates that the field value must have the specified
   * number of characters (Unicode code points), which may differ from the number
   * of bytes in the string. If the field value does not meet the specified
   * length, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value length must be 5 characters
   * string value = 1 [(buf.validate.field).string.len = 5];
   * }
   * ```
   * </pre>
   *
   * <code>optional uint64 len = 19 [json_name = "len", (.buf.validate.predefined) = { ... }</code>
   * @return The len.
   */
  long getLen();

  /**
   * <pre>
   * `min_len` specifies that the field value must have at least the specified
   * number of characters (Unicode code points), which may differ from the number
   * of bytes in the string. If the field value contains fewer characters, an error
   * message will be generated.
   *
   * ```proto
   * message MyString {
   * // value length must be at least 3 characters
   * string value = 1 [(buf.validate.field).string.min_len = 3];
   * }
   * ```
   * </pre>
   *
   * <code>optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the minLen field is set.
   */
  boolean hasMinLen();
  /**
   * <pre>
   * `min_len` specifies that the field value must have at least the specified
   * number of characters (Unicode code points), which may differ from the number
   * of bytes in the string. If the field value contains fewer characters, an error
   * message will be generated.
   *
   * ```proto
   * message MyString {
   * // value length must be at least 3 characters
   * string value = 1 [(buf.validate.field).string.min_len = 3];
   * }
   * ```
   * </pre>
   *
   * <code>optional uint64 min_len = 2 [json_name = "minLen", (.buf.validate.predefined) = { ... }</code>
   * @return The minLen.
   */
  long getMinLen();

  /**
   * <pre>
   * `max_len` specifies that the field value must have no more than the specified
   * number of characters (Unicode code points), which may differ from the
   * number of bytes in the string. If the field value contains more characters,
   * an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value length must be at most 10 characters
   * string value = 1 [(buf.validate.field).string.max_len = 10];
   * }
   * ```
   * </pre>
   *
   * <code>optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the maxLen field is set.
   */
  boolean hasMaxLen();
  /**
   * <pre>
   * `max_len` specifies that the field value must have no more than the specified
   * number of characters (Unicode code points), which may differ from the
   * number of bytes in the string. If the field value contains more characters,
   * an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value length must be at most 10 characters
   * string value = 1 [(buf.validate.field).string.max_len = 10];
   * }
   * ```
   * </pre>
   *
   * <code>optional uint64 max_len = 3 [json_name = "maxLen", (.buf.validate.predefined) = { ... }</code>
   * @return The maxLen.
   */
  long getMaxLen();

  /**
   * <pre>
   * `len_bytes` dictates that the field value must have the specified number of
   * bytes. If the field value does not match the specified length in bytes,
   * an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value length must be 6 bytes
   * string value = 1 [(buf.validate.field).string.len_bytes = 6];
   * }
   * ```
   * </pre>
   *
   * <code>optional uint64 len_bytes = 20 [json_name = "lenBytes", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the lenBytes field is set.
   */
  boolean hasLenBytes();
  /**
   * <pre>
   * `len_bytes` dictates that the field value must have the specified number of
   * bytes. If the field value does not match the specified length in bytes,
   * an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value length must be 6 bytes
   * string value = 1 [(buf.validate.field).string.len_bytes = 6];
   * }
   * ```
   * </pre>
   *
   * <code>optional uint64 len_bytes = 20 [json_name = "lenBytes", (.buf.validate.predefined) = { ... }</code>
   * @return The lenBytes.
   */
  long getLenBytes();

  /**
   * <pre>
   * `min_bytes` specifies that the field value must have at least the specified
   * number of bytes. If the field value contains fewer bytes, an error message
   * will be generated.
   *
   * ```proto
   * message MyString {
   * // value length must be at least 4 bytes
   * string value = 1 [(buf.validate.field).string.min_bytes = 4];
   * }
   *
   * ```
   * </pre>
   *
   * <code>optional uint64 min_bytes = 4 [json_name = "minBytes", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the minBytes field is set.
   */
  boolean hasMinBytes();
  /**
   * <pre>
   * `min_bytes` specifies that the field value must have at least the specified
   * number of bytes. If the field value contains fewer bytes, an error message
   * will be generated.
   *
   * ```proto
   * message MyString {
   * // value length must be at least 4 bytes
   * string value = 1 [(buf.validate.field).string.min_bytes = 4];
   * }
   *
   * ```
   * </pre>
   *
   * <code>optional uint64 min_bytes = 4 [json_name = "minBytes", (.buf.validate.predefined) = { ... }</code>
   * @return The minBytes.
   */
  long getMinBytes();

  /**
   * <pre>
   * `max_bytes` specifies that the field value must have no more than the
   * specified number of bytes. If the field value contains more bytes, an
   * error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value length must be at most 8 bytes
   * string value = 1 [(buf.validate.field).string.max_bytes = 8];
   * }
   * ```
   * </pre>
   *
   * <code>optional uint64 max_bytes = 5 [json_name = "maxBytes", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the maxBytes field is set.
   */
  boolean hasMaxBytes();
  /**
   * <pre>
   * `max_bytes` specifies that the field value must have no more than the
   * specified number of bytes. If the field value contains more bytes, an
   * error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value length must be at most 8 bytes
   * string value = 1 [(buf.validate.field).string.max_bytes = 8];
   * }
   * ```
   * </pre>
   *
   * <code>optional uint64 max_bytes = 5 [json_name = "maxBytes", (.buf.validate.predefined) = { ... }</code>
   * @return The maxBytes.
   */
  long getMaxBytes();

  /**
   * <pre>
   * `pattern` specifies that the field value must match the specified
   * regular expression (RE2 syntax), with the expression provided without any
   * delimiters. If the field value doesn't match the regular expression, an
   * error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value does not match regex pattern `^[a-zA-Z]//$`
   * string value = 1 [(buf.validate.field).string.pattern = "^[a-zA-Z]//$"];
   * }
   * ```
   * </pre>
   *
   * <code>optional string pattern = 6 [json_name = "pattern", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the pattern field is set.
   */
  boolean hasPattern();
  /**
   * <pre>
   * `pattern` specifies that the field value must match the specified
   * regular expression (RE2 syntax), with the expression provided without any
   * delimiters. If the field value doesn't match the regular expression, an
   * error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value does not match regex pattern `^[a-zA-Z]//$`
   * string value = 1 [(buf.validate.field).string.pattern = "^[a-zA-Z]//$"];
   * }
   * ```
   * </pre>
   *
   * <code>optional string pattern = 6 [json_name = "pattern", (.buf.validate.predefined) = { ... }</code>
   * @return The pattern.
   */
  java.lang.String getPattern();
  /**
   * <pre>
   * `pattern` specifies that the field value must match the specified
   * regular expression (RE2 syntax), with the expression provided without any
   * delimiters. If the field value doesn't match the regular expression, an
   * error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value does not match regex pattern `^[a-zA-Z]//$`
   * string value = 1 [(buf.validate.field).string.pattern = "^[a-zA-Z]//$"];
   * }
   * ```
   * </pre>
   *
   * <code>optional string pattern = 6 [json_name = "pattern", (.buf.validate.predefined) = { ... }</code>
   * @return The bytes for pattern.
   */
  com.google.protobuf.ByteString
      getPatternBytes();

  /**
   * <pre>
   * `prefix` specifies that the field value must have the
   * specified substring at the beginning of the string. If the field value
   * doesn't start with the specified prefix, an error message will be
   * generated.
   *
   * ```proto
   * message MyString {
   * // value does not have prefix `pre`
   * string value = 1 [(buf.validate.field).string.prefix = "pre"];
   * }
   * ```
   * </pre>
   *
   * <code>optional string prefix = 7 [json_name = "prefix", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the prefix field is set.
   */
  boolean hasPrefix();
  /**
   * <pre>
   * `prefix` specifies that the field value must have the
   * specified substring at the beginning of the string. If the field value
   * doesn't start with the specified prefix, an error message will be
   * generated.
   *
   * ```proto
   * message MyString {
   * // value does not have prefix `pre`
   * string value = 1 [(buf.validate.field).string.prefix = "pre"];
   * }
   * ```
   * </pre>
   *
   * <code>optional string prefix = 7 [json_name = "prefix", (.buf.validate.predefined) = { ... }</code>
   * @return The prefix.
   */
  java.lang.String getPrefix();
  /**
   * <pre>
   * `prefix` specifies that the field value must have the
   * specified substring at the beginning of the string. If the field value
   * doesn't start with the specified prefix, an error message will be
   * generated.
   *
   * ```proto
   * message MyString {
   * // value does not have prefix `pre`
   * string value = 1 [(buf.validate.field).string.prefix = "pre"];
   * }
   * ```
   * </pre>
   *
   * <code>optional string prefix = 7 [json_name = "prefix", (.buf.validate.predefined) = { ... }</code>
   * @return The bytes for prefix.
   */
  com.google.protobuf.ByteString
      getPrefixBytes();

  /**
   * <pre>
   * `suffix` specifies that the field value must have the
   * specified substring at the end of the string. If the field value doesn't
   * end with the specified suffix, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value does not have suffix `post`
   * string value = 1 [(buf.validate.field).string.suffix = "post"];
   * }
   * ```
   * </pre>
   *
   * <code>optional string suffix = 8 [json_name = "suffix", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the suffix field is set.
   */
  boolean hasSuffix();
  /**
   * <pre>
   * `suffix` specifies that the field value must have the
   * specified substring at the end of the string. If the field value doesn't
   * end with the specified suffix, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value does not have suffix `post`
   * string value = 1 [(buf.validate.field).string.suffix = "post"];
   * }
   * ```
   * </pre>
   *
   * <code>optional string suffix = 8 [json_name = "suffix", (.buf.validate.predefined) = { ... }</code>
   * @return The suffix.
   */
  java.lang.String getSuffix();
  /**
   * <pre>
   * `suffix` specifies that the field value must have the
   * specified substring at the end of the string. If the field value doesn't
   * end with the specified suffix, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value does not have suffix `post`
   * string value = 1 [(buf.validate.field).string.suffix = "post"];
   * }
   * ```
   * </pre>
   *
   * <code>optional string suffix = 8 [json_name = "suffix", (.buf.validate.predefined) = { ... }</code>
   * @return The bytes for suffix.
   */
  com.google.protobuf.ByteString
      getSuffixBytes();

  /**
   * <pre>
   * `contains` specifies that the field value must have the
   * specified substring anywhere in the string. If the field value doesn't
   * contain the specified substring, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value does not contain substring `inside`.
   * string value = 1 [(buf.validate.field).string.contains = "inside"];
   * }
   * ```
   * </pre>
   *
   * <code>optional string contains = 9 [json_name = "contains", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the contains field is set.
   */
  boolean hasContains();
  /**
   * <pre>
   * `contains` specifies that the field value must have the
   * specified substring anywhere in the string. If the field value doesn't
   * contain the specified substring, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value does not contain substring `inside`.
   * string value = 1 [(buf.validate.field).string.contains = "inside"];
   * }
   * ```
   * </pre>
   *
   * <code>optional string contains = 9 [json_name = "contains", (.buf.validate.predefined) = { ... }</code>
   * @return The contains.
   */
  java.lang.String getContains();
  /**
   * <pre>
   * `contains` specifies that the field value must have the
   * specified substring anywhere in the string. If the field value doesn't
   * contain the specified substring, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value does not contain substring `inside`.
   * string value = 1 [(buf.validate.field).string.contains = "inside"];
   * }
   * ```
   * </pre>
   *
   * <code>optional string contains = 9 [json_name = "contains", (.buf.validate.predefined) = { ... }</code>
   * @return The bytes for contains.
   */
  com.google.protobuf.ByteString
      getContainsBytes();

  /**
   * <pre>
   * `not_contains` specifies that the field value must not have the
   * specified substring anywhere in the string. If the field value contains
   * the specified substring, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value contains substring `inside`.
   * string value = 1 [(buf.validate.field).string.not_contains = "inside"];
   * }
   * ```
   * </pre>
   *
   * <code>optional string not_contains = 23 [json_name = "notContains", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the notContains field is set.
   */
  boolean hasNotContains();
  /**
   * <pre>
   * `not_contains` specifies that the field value must not have the
   * specified substring anywhere in the string. If the field value contains
   * the specified substring, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value contains substring `inside`.
   * string value = 1 [(buf.validate.field).string.not_contains = "inside"];
   * }
   * ```
   * </pre>
   *
   * <code>optional string not_contains = 23 [json_name = "notContains", (.buf.validate.predefined) = { ... }</code>
   * @return The notContains.
   */
  java.lang.String getNotContains();
  /**
   * <pre>
   * `not_contains` specifies that the field value must not have the
   * specified substring anywhere in the string. If the field value contains
   * the specified substring, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value contains substring `inside`.
   * string value = 1 [(buf.validate.field).string.not_contains = "inside"];
   * }
   * ```
   * </pre>
   *
   * <code>optional string not_contains = 23 [json_name = "notContains", (.buf.validate.predefined) = { ... }</code>
   * @return The bytes for notContains.
   */
  com.google.protobuf.ByteString
      getNotContainsBytes();

  /**
   * <pre>
   * `in` specifies that the field value must be equal to one of the specified
   * values. If the field value isn't one of the specified values, an error
   * message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be in list ["apple", "banana"]
   * string value = 1 [(buf.validate.field).string.in = "apple", (buf.validate.field).string.in = "banana"];
   * }
   * ```
   * </pre>
   *
   * <code>repeated string in = 10 [json_name = "in", (.buf.validate.predefined) = { ... }</code>
   * @return A list containing the in.
   */
  java.util.List<java.lang.String>
      getInList();
  /**
   * <pre>
   * `in` specifies that the field value must be equal to one of the specified
   * values. If the field value isn't one of the specified values, an error
   * message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be in list ["apple", "banana"]
   * string value = 1 [(buf.validate.field).string.in = "apple", (buf.validate.field).string.in = "banana"];
   * }
   * ```
   * </pre>
   *
   * <code>repeated string in = 10 [json_name = "in", (.buf.validate.predefined) = { ... }</code>
   * @return The count of in.
   */
  int getInCount();
  /**
   * <pre>
   * `in` specifies that the field value must be equal to one of the specified
   * values. If the field value isn't one of the specified values, an error
   * message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be in list ["apple", "banana"]
   * string value = 1 [(buf.validate.field).string.in = "apple", (buf.validate.field).string.in = "banana"];
   * }
   * ```
   * </pre>
   *
   * <code>repeated string in = 10 [json_name = "in", (.buf.validate.predefined) = { ... }</code>
   * @param index The index of the element to return.
   * @return The in at the given index.
   */
  java.lang.String getIn(int index);
  /**
   * <pre>
   * `in` specifies that the field value must be equal to one of the specified
   * values. If the field value isn't one of the specified values, an error
   * message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be in list ["apple", "banana"]
   * string value = 1 [(buf.validate.field).string.in = "apple", (buf.validate.field).string.in = "banana"];
   * }
   * ```
   * </pre>
   *
   * <code>repeated string in = 10 [json_name = "in", (.buf.validate.predefined) = { ... }</code>
   * @param index The index of the value to return.
   * @return The bytes of the in at the given index.
   */
  com.google.protobuf.ByteString
      getInBytes(int index);

  /**
   * <pre>
   * `not_in` specifies that the field value cannot be equal to any
   * of the specified values. If the field value is one of the specified values,
   * an error message will be generated.
   * ```proto
   * message MyString {
   * // value must not be in list ["orange", "grape"]
   * string value = 1 [(buf.validate.field).string.not_in = "orange", (buf.validate.field).string.not_in = "grape"];
   * }
   * ```
   * </pre>
   *
   * <code>repeated string not_in = 11 [json_name = "notIn", (.buf.validate.predefined) = { ... }</code>
   * @return A list containing the notIn.
   */
  java.util.List<java.lang.String>
      getNotInList();
  /**
   * <pre>
   * `not_in` specifies that the field value cannot be equal to any
   * of the specified values. If the field value is one of the specified values,
   * an error message will be generated.
   * ```proto
   * message MyString {
   * // value must not be in list ["orange", "grape"]
   * string value = 1 [(buf.validate.field).string.not_in = "orange", (buf.validate.field).string.not_in = "grape"];
   * }
   * ```
   * </pre>
   *
   * <code>repeated string not_in = 11 [json_name = "notIn", (.buf.validate.predefined) = { ... }</code>
   * @return The count of notIn.
   */
  int getNotInCount();
  /**
   * <pre>
   * `not_in` specifies that the field value cannot be equal to any
   * of the specified values. If the field value is one of the specified values,
   * an error message will be generated.
   * ```proto
   * message MyString {
   * // value must not be in list ["orange", "grape"]
   * string value = 1 [(buf.validate.field).string.not_in = "orange", (buf.validate.field).string.not_in = "grape"];
   * }
   * ```
   * </pre>
   *
   * <code>repeated string not_in = 11 [json_name = "notIn", (.buf.validate.predefined) = { ... }</code>
   * @param index The index of the element to return.
   * @return The notIn at the given index.
   */
  java.lang.String getNotIn(int index);
  /**
   * <pre>
   * `not_in` specifies that the field value cannot be equal to any
   * of the specified values. If the field value is one of the specified values,
   * an error message will be generated.
   * ```proto
   * message MyString {
   * // value must not be in list ["orange", "grape"]
   * string value = 1 [(buf.validate.field).string.not_in = "orange", (buf.validate.field).string.not_in = "grape"];
   * }
   * ```
   * </pre>
   *
   * <code>repeated string not_in = 11 [json_name = "notIn", (.buf.validate.predefined) = { ... }</code>
   * @param index The index of the value to return.
   * @return The bytes of the notIn at the given index.
   */
  com.google.protobuf.ByteString
      getNotInBytes(int index);

  /**
   * <pre>
   * `email` specifies that the field value must be a valid email address, for
   * example "foo&#64;example.com".
   *
   * Conforms to the definition for a valid email address from the [HTML standard](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address).
   * Note that this standard willfully deviates from [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322),
   * which allows many unexpected forms of email addresses and will easily match
   * a typographical error.
   *
   * If the field value isn't a valid email address, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid email address
   * string value = 1 [(buf.validate.field).string.email = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool email = 12 [json_name = "email", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the email field is set.
   */
  boolean hasEmail();
  /**
   * <pre>
   * `email` specifies that the field value must be a valid email address, for
   * example "foo&#64;example.com".
   *
   * Conforms to the definition for a valid email address from the [HTML standard](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address).
   * Note that this standard willfully deviates from [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322),
   * which allows many unexpected forms of email addresses and will easily match
   * a typographical error.
   *
   * If the field value isn't a valid email address, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid email address
   * string value = 1 [(buf.validate.field).string.email = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool email = 12 [json_name = "email", (.buf.validate.predefined) = { ... }</code>
   * @return The email.
   */
  boolean getEmail();

  /**
   * <pre>
   * `hostname` specifies that the field value must be a valid hostname, for
   * example "foo.example.com".
   *
   * A valid hostname follows the rules below:
   * - The name consists of one or more labels, separated by a dot (".").
   * - Each label can be 1 to 63 alphanumeric characters.
   * - A label can contain hyphens ("-"), but must not start or end with a hyphen.
   * - The right-most label must not be digits only.
   * - The name can have a trailing dot—for example, "foo.example.com.".
   * - The name can be 253 characters at most, excluding the optional trailing dot.
   *
   * If the field value isn't a valid hostname, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid hostname
   * string value = 1 [(buf.validate.field).string.hostname = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool hostname = 13 [json_name = "hostname", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the hostname field is set.
   */
  boolean hasHostname();
  /**
   * <pre>
   * `hostname` specifies that the field value must be a valid hostname, for
   * example "foo.example.com".
   *
   * A valid hostname follows the rules below:
   * - The name consists of one or more labels, separated by a dot (".").
   * - Each label can be 1 to 63 alphanumeric characters.
   * - A label can contain hyphens ("-"), but must not start or end with a hyphen.
   * - The right-most label must not be digits only.
   * - The name can have a trailing dot—for example, "foo.example.com.".
   * - The name can be 253 characters at most, excluding the optional trailing dot.
   *
   * If the field value isn't a valid hostname, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid hostname
   * string value = 1 [(buf.validate.field).string.hostname = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool hostname = 13 [json_name = "hostname", (.buf.validate.predefined) = { ... }</code>
   * @return The hostname.
   */
  boolean getHostname();

  /**
   * <pre>
   * `ip` specifies that the field value must be a valid IP (v4 or v6) address.
   *
   * IPv4 addresses are expected in the dotted decimal format—for example, "192.168.5.21".
   * IPv6 addresses are expected in their text representation—for example, "::1",
   * or "2001:0DB8:ABCD:0012::0".
   *
   * Both formats are well-defined in the internet standard [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986).
   * Zone identifiers for IPv6 addresses (for example, "fe80::a%en1") are supported.
   *
   * If the field value isn't a valid IP address, an error message will be
   * generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid IP address
   * string value = 1 [(buf.validate.field).string.ip = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool ip = 14 [json_name = "ip", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the ip field is set.
   */
  boolean hasIp();
  /**
   * <pre>
   * `ip` specifies that the field value must be a valid IP (v4 or v6) address.
   *
   * IPv4 addresses are expected in the dotted decimal format—for example, "192.168.5.21".
   * IPv6 addresses are expected in their text representation—for example, "::1",
   * or "2001:0DB8:ABCD:0012::0".
   *
   * Both formats are well-defined in the internet standard [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986).
   * Zone identifiers for IPv6 addresses (for example, "fe80::a%en1") are supported.
   *
   * If the field value isn't a valid IP address, an error message will be
   * generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid IP address
   * string value = 1 [(buf.validate.field).string.ip = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool ip = 14 [json_name = "ip", (.buf.validate.predefined) = { ... }</code>
   * @return The ip.
   */
  boolean getIp();

  /**
   * <pre>
   * `ipv4` specifies that the field value must be a valid IPv4 address—for
   * example "192.168.5.21". If the field value isn't a valid IPv4 address, an
   * error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid IPv4 address
   * string value = 1 [(buf.validate.field).string.ipv4 = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool ipv4 = 15 [json_name = "ipv4", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the ipv4 field is set.
   */
  boolean hasIpv4();
  /**
   * <pre>
   * `ipv4` specifies that the field value must be a valid IPv4 address—for
   * example "192.168.5.21". If the field value isn't a valid IPv4 address, an
   * error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid IPv4 address
   * string value = 1 [(buf.validate.field).string.ipv4 = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool ipv4 = 15 [json_name = "ipv4", (.buf.validate.predefined) = { ... }</code>
   * @return The ipv4.
   */
  boolean getIpv4();

  /**
   * <pre>
   * `ipv6` specifies that the field value must be a valid IPv6 address—for
   * example "::1", or "d7a:115c:a1e0:ab12:4843:cd96:626b:430b". If the field
   * value is not a valid IPv6 address, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid IPv6 address
   * string value = 1 [(buf.validate.field).string.ipv6 = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool ipv6 = 16 [json_name = "ipv6", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the ipv6 field is set.
   */
  boolean hasIpv6();
  /**
   * <pre>
   * `ipv6` specifies that the field value must be a valid IPv6 address—for
   * example "::1", or "d7a:115c:a1e0:ab12:4843:cd96:626b:430b". If the field
   * value is not a valid IPv6 address, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid IPv6 address
   * string value = 1 [(buf.validate.field).string.ipv6 = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool ipv6 = 16 [json_name = "ipv6", (.buf.validate.predefined) = { ... }</code>
   * @return The ipv6.
   */
  boolean getIpv6();

  /**
   * <pre>
   * `uri` specifies that the field value must be a valid URI, for example
   * "https://example.com/foo/bar?baz=quux#frag".
   *
   * URI is defined in the internet standard [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986).
   * Zone Identifiers in IPv6 address literals are supported ([RFC 6874](https://datatracker.ietf.org/doc/html/rfc6874)).
   *
   * If the field value isn't a valid URI, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid URI
   * string value = 1 [(buf.validate.field).string.uri = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool uri = 17 [json_name = "uri", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the uri field is set.
   */
  boolean hasUri();
  /**
   * <pre>
   * `uri` specifies that the field value must be a valid URI, for example
   * "https://example.com/foo/bar?baz=quux#frag".
   *
   * URI is defined in the internet standard [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986).
   * Zone Identifiers in IPv6 address literals are supported ([RFC 6874](https://datatracker.ietf.org/doc/html/rfc6874)).
   *
   * If the field value isn't a valid URI, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid URI
   * string value = 1 [(buf.validate.field).string.uri = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool uri = 17 [json_name = "uri", (.buf.validate.predefined) = { ... }</code>
   * @return The uri.
   */
  boolean getUri();

  /**
   * <pre>
   * `uri_ref` specifies that the field value must be a valid URI Reference—either
   * a URI such as "https://example.com/foo/bar?baz=quux#frag", or a Relative
   * Reference such as "./foo/bar?query".
   *
   * URI, URI Reference, and Relative Reference are defined in the internet
   * standard [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986). Zone
   * Identifiers in IPv6 address literals are supported ([RFC 6874](https://datatracker.ietf.org/doc/html/rfc6874)).
   *
   * If the field value isn't a valid URI Reference, an error message will be
   * generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid URI Reference
   * string value = 1 [(buf.validate.field).string.uri_ref = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool uri_ref = 18 [json_name = "uriRef", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the uriRef field is set.
   */
  boolean hasUriRef();
  /**
   * <pre>
   * `uri_ref` specifies that the field value must be a valid URI Reference—either
   * a URI such as "https://example.com/foo/bar?baz=quux#frag", or a Relative
   * Reference such as "./foo/bar?query".
   *
   * URI, URI Reference, and Relative Reference are defined in the internet
   * standard [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986). Zone
   * Identifiers in IPv6 address literals are supported ([RFC 6874](https://datatracker.ietf.org/doc/html/rfc6874)).
   *
   * If the field value isn't a valid URI Reference, an error message will be
   * generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid URI Reference
   * string value = 1 [(buf.validate.field).string.uri_ref = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool uri_ref = 18 [json_name = "uriRef", (.buf.validate.predefined) = { ... }</code>
   * @return The uriRef.
   */
  boolean getUriRef();

  /**
   * <pre>
   * `address` specifies that the field value must be either a valid hostname
   * (for example, "example.com"), or a valid IP (v4 or v6) address (for example,
   * "192.168.0.1", or "::1"). If the field value isn't a valid hostname or IP,
   * an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid hostname, or ip address
   * string value = 1 [(buf.validate.field).string.address = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool address = 21 [json_name = "address", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the address field is set.
   */
  boolean hasAddress();
  /**
   * <pre>
   * `address` specifies that the field value must be either a valid hostname
   * (for example, "example.com"), or a valid IP (v4 or v6) address (for example,
   * "192.168.0.1", or "::1"). If the field value isn't a valid hostname or IP,
   * an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid hostname, or ip address
   * string value = 1 [(buf.validate.field).string.address = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool address = 21 [json_name = "address", (.buf.validate.predefined) = { ... }</code>
   * @return The address.
   */
  boolean getAddress();

  /**
   * <pre>
   * `uuid` specifies that the field value must be a valid UUID as defined by
   * [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.2). If the
   * field value isn't a valid UUID, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid UUID
   * string value = 1 [(buf.validate.field).string.uuid = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool uuid = 22 [json_name = "uuid", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the uuid field is set.
   */
  boolean hasUuid();
  /**
   * <pre>
   * `uuid` specifies that the field value must be a valid UUID as defined by
   * [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.2). If the
   * field value isn't a valid UUID, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid UUID
   * string value = 1 [(buf.validate.field).string.uuid = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool uuid = 22 [json_name = "uuid", (.buf.validate.predefined) = { ... }</code>
   * @return The uuid.
   */
  boolean getUuid();

  /**
   * <pre>
   * `tuuid` (trimmed UUID) specifies that the field value must be a valid UUID as
   * defined by [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.2) with all dashes
   * omitted. If the field value isn't a valid UUID without dashes, an error message
   * will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid trimmed UUID
   * string value = 1 [(buf.validate.field).string.tuuid = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool tuuid = 33 [json_name = "tuuid", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the tuuid field is set.
   */
  boolean hasTuuid();
  /**
   * <pre>
   * `tuuid` (trimmed UUID) specifies that the field value must be a valid UUID as
   * defined by [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122#section-4.1.2) with all dashes
   * omitted. If the field value isn't a valid UUID without dashes, an error message
   * will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid trimmed UUID
   * string value = 1 [(buf.validate.field).string.tuuid = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool tuuid = 33 [json_name = "tuuid", (.buf.validate.predefined) = { ... }</code>
   * @return The tuuid.
   */
  boolean getTuuid();

  /**
   * <pre>
   * `ip_with_prefixlen` specifies that the field value must be a valid IP
   * (v4 or v6) address with prefix length—for example, "192.168.5.21/16" or
   * "2001:0DB8:ABCD:0012::F1/64". If the field value isn't a valid IP with
   * prefix length, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid IP with prefix length
   * string value = 1 [(buf.validate.field).string.ip_with_prefixlen = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool ip_with_prefixlen = 26 [json_name = "ipWithPrefixlen", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the ipWithPrefixlen field is set.
   */
  boolean hasIpWithPrefixlen();
  /**
   * <pre>
   * `ip_with_prefixlen` specifies that the field value must be a valid IP
   * (v4 or v6) address with prefix length—for example, "192.168.5.21/16" or
   * "2001:0DB8:ABCD:0012::F1/64". If the field value isn't a valid IP with
   * prefix length, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid IP with prefix length
   * string value = 1 [(buf.validate.field).string.ip_with_prefixlen = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool ip_with_prefixlen = 26 [json_name = "ipWithPrefixlen", (.buf.validate.predefined) = { ... }</code>
   * @return The ipWithPrefixlen.
   */
  boolean getIpWithPrefixlen();

  /**
   * <pre>
   * `ipv4_with_prefixlen` specifies that the field value must be a valid
   * IPv4 address with prefix length—for example, "192.168.5.21/16". If the
   * field value isn't a valid IPv4 address with prefix length, an error
   * message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid IPv4 address with prefix length
   * string value = 1 [(buf.validate.field).string.ipv4_with_prefixlen = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool ipv4_with_prefixlen = 27 [json_name = "ipv4WithPrefixlen", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the ipv4WithPrefixlen field is set.
   */
  boolean hasIpv4WithPrefixlen();
  /**
   * <pre>
   * `ipv4_with_prefixlen` specifies that the field value must be a valid
   * IPv4 address with prefix length—for example, "192.168.5.21/16". If the
   * field value isn't a valid IPv4 address with prefix length, an error
   * message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid IPv4 address with prefix length
   * string value = 1 [(buf.validate.field).string.ipv4_with_prefixlen = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool ipv4_with_prefixlen = 27 [json_name = "ipv4WithPrefixlen", (.buf.validate.predefined) = { ... }</code>
   * @return The ipv4WithPrefixlen.
   */
  boolean getIpv4WithPrefixlen();

  /**
   * <pre>
   * `ipv6_with_prefixlen` specifies that the field value must be a valid
   * IPv6 address with prefix length—for example, "2001:0DB8:ABCD:0012::F1/64".
   * If the field value is not a valid IPv6 address with prefix length,
   * an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid IPv6 address prefix length
   * string value = 1 [(buf.validate.field).string.ipv6_with_prefixlen = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool ipv6_with_prefixlen = 28 [json_name = "ipv6WithPrefixlen", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the ipv6WithPrefixlen field is set.
   */
  boolean hasIpv6WithPrefixlen();
  /**
   * <pre>
   * `ipv6_with_prefixlen` specifies that the field value must be a valid
   * IPv6 address with prefix length—for example, "2001:0DB8:ABCD:0012::F1/64".
   * If the field value is not a valid IPv6 address with prefix length,
   * an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid IPv6 address prefix length
   * string value = 1 [(buf.validate.field).string.ipv6_with_prefixlen = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool ipv6_with_prefixlen = 28 [json_name = "ipv6WithPrefixlen", (.buf.validate.predefined) = { ... }</code>
   * @return The ipv6WithPrefixlen.
   */
  boolean getIpv6WithPrefixlen();

  /**
   * <pre>
   * `ip_prefix` specifies that the field value must be a valid IP (v4 or v6)
   * prefix—for example, "192.168.0.0/16" or "2001:0DB8:ABCD:0012::0/64".
   *
   * The prefix must have all zeros for the unmasked bits. For example,
   * "2001:0DB8:ABCD:0012::0/64" designates the left-most 64 bits for the
   * prefix, and the remaining 64 bits must be zero.
   *
   * If the field value isn't a valid IP prefix, an error message will be
   * generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid IP prefix
   * string value = 1 [(buf.validate.field).string.ip_prefix = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool ip_prefix = 29 [json_name = "ipPrefix", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the ipPrefix field is set.
   */
  boolean hasIpPrefix();
  /**
   * <pre>
   * `ip_prefix` specifies that the field value must be a valid IP (v4 or v6)
   * prefix—for example, "192.168.0.0/16" or "2001:0DB8:ABCD:0012::0/64".
   *
   * The prefix must have all zeros for the unmasked bits. For example,
   * "2001:0DB8:ABCD:0012::0/64" designates the left-most 64 bits for the
   * prefix, and the remaining 64 bits must be zero.
   *
   * If the field value isn't a valid IP prefix, an error message will be
   * generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid IP prefix
   * string value = 1 [(buf.validate.field).string.ip_prefix = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool ip_prefix = 29 [json_name = "ipPrefix", (.buf.validate.predefined) = { ... }</code>
   * @return The ipPrefix.
   */
  boolean getIpPrefix();

  /**
   * <pre>
   * `ipv4_prefix` specifies that the field value must be a valid IPv4
   * prefix, for example "192.168.0.0/16".
   *
   * The prefix must have all zeros for the unmasked bits. For example,
   * "192.168.0.0/16" designates the left-most 16 bits for the prefix,
   * and the remaining 16 bits must be zero.
   *
   * If the field value isn't a valid IPv4 prefix, an error message
   * will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid IPv4 prefix
   * string value = 1 [(buf.validate.field).string.ipv4_prefix = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool ipv4_prefix = 30 [json_name = "ipv4Prefix", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the ipv4Prefix field is set.
   */
  boolean hasIpv4Prefix();
  /**
   * <pre>
   * `ipv4_prefix` specifies that the field value must be a valid IPv4
   * prefix, for example "192.168.0.0/16".
   *
   * The prefix must have all zeros for the unmasked bits. For example,
   * "192.168.0.0/16" designates the left-most 16 bits for the prefix,
   * and the remaining 16 bits must be zero.
   *
   * If the field value isn't a valid IPv4 prefix, an error message
   * will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid IPv4 prefix
   * string value = 1 [(buf.validate.field).string.ipv4_prefix = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool ipv4_prefix = 30 [json_name = "ipv4Prefix", (.buf.validate.predefined) = { ... }</code>
   * @return The ipv4Prefix.
   */
  boolean getIpv4Prefix();

  /**
   * <pre>
   * `ipv6_prefix` specifies that the field value must be a valid IPv6 prefix—for
   * example, "2001:0DB8:ABCD:0012::0/64".
   *
   * The prefix must have all zeros for the unmasked bits. For example,
   * "2001:0DB8:ABCD:0012::0/64" designates the left-most 64 bits for the
   * prefix, and the remaining 64 bits must be zero.
   *
   * If the field value is not a valid IPv6 prefix, an error message will be
   * generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid IPv6 prefix
   * string value = 1 [(buf.validate.field).string.ipv6_prefix = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool ipv6_prefix = 31 [json_name = "ipv6Prefix", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the ipv6Prefix field is set.
   */
  boolean hasIpv6Prefix();
  /**
   * <pre>
   * `ipv6_prefix` specifies that the field value must be a valid IPv6 prefix—for
   * example, "2001:0DB8:ABCD:0012::0/64".
   *
   * The prefix must have all zeros for the unmasked bits. For example,
   * "2001:0DB8:ABCD:0012::0/64" designates the left-most 64 bits for the
   * prefix, and the remaining 64 bits must be zero.
   *
   * If the field value is not a valid IPv6 prefix, an error message will be
   * generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid IPv6 prefix
   * string value = 1 [(buf.validate.field).string.ipv6_prefix = true];
   * }
   * ```
   * </pre>
   *
   * <code>bool ipv6_prefix = 31 [json_name = "ipv6Prefix", (.buf.validate.predefined) = { ... }</code>
   * @return The ipv6Prefix.
   */
  boolean getIpv6Prefix();

  /**
   * <pre>
   * `host_and_port` specifies that the field value must be valid host/port
   * pair—for example, "example.com:8080".
   *
   * The host can be one of:
   * - An IPv4 address in dotted decimal format—for example, "192.168.5.21".
   * - An IPv6 address enclosed in square brackets—for example, "[2001:0DB8:ABCD:0012::F1]".
   * - A hostname—for example, "example.com".
   *
   * The port is separated by a colon. It must be non-empty, with a decimal number
   * in the range of 0-65535, inclusive.
   * </pre>
   *
   * <code>bool host_and_port = 32 [json_name = "hostAndPort", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the hostAndPort field is set.
   */
  boolean hasHostAndPort();
  /**
   * <pre>
   * `host_and_port` specifies that the field value must be valid host/port
   * pair—for example, "example.com:8080".
   *
   * The host can be one of:
   * - An IPv4 address in dotted decimal format—for example, "192.168.5.21".
   * - An IPv6 address enclosed in square brackets—for example, "[2001:0DB8:ABCD:0012::F1]".
   * - A hostname—for example, "example.com".
   *
   * The port is separated by a colon. It must be non-empty, with a decimal number
   * in the range of 0-65535, inclusive.
   * </pre>
   *
   * <code>bool host_and_port = 32 [json_name = "hostAndPort", (.buf.validate.predefined) = { ... }</code>
   * @return The hostAndPort.
   */
  boolean getHostAndPort();

  /**
   * <pre>
   * `well_known_regex` specifies a common well-known pattern
   * defined as a regex. If the field value doesn't match the well-known
   * regex, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid HTTP header value
   * string value = 1 [(buf.validate.field).string.well_known_regex = KNOWN_REGEX_HTTP_HEADER_VALUE];
   * }
   * ```
   *
   * #### KnownRegex
   *
   * `well_known_regex` contains some well-known patterns.
   *
   * | Name                          | Number | Description                               |
   * |-------------------------------|--------|-------------------------------------------|
   * | KNOWN_REGEX_UNSPECIFIED       | 0      |                                           |
   * | KNOWN_REGEX_HTTP_HEADER_NAME  | 1      | HTTP header name as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2)  |
   * | KNOWN_REGEX_HTTP_HEADER_VALUE | 2      | HTTP header value as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.4) |
   * </pre>
   *
   * <code>.buf.validate.KnownRegex well_known_regex = 24 [json_name = "wellKnownRegex", (.buf.validate.predefined) = { ... }</code>
   * @return Whether the wellKnownRegex field is set.
   */
  boolean hasWellKnownRegex();
  /**
   * <pre>
   * `well_known_regex` specifies a common well-known pattern
   * defined as a regex. If the field value doesn't match the well-known
   * regex, an error message will be generated.
   *
   * ```proto
   * message MyString {
   * // value must be a valid HTTP header value
   * string value = 1 [(buf.validate.field).string.well_known_regex = KNOWN_REGEX_HTTP_HEADER_VALUE];
   * }
   * ```
   *
   * #### KnownRegex
   *
   * `well_known_regex` contains some well-known patterns.
   *
   * | Name                          | Number | Description                               |
   * |-------------------------------|--------|-------------------------------------------|
   * | KNOWN_REGEX_UNSPECIFIED       | 0      |                                           |
   * | KNOWN_REGEX_HTTP_HEADER_NAME  | 1      | HTTP header name as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2)  |
   * | KNOWN_REGEX_HTTP_HEADER_VALUE | 2      | HTTP header value as defined by [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.4) |
   * </pre>
   *
   * <code>.buf.validate.KnownRegex well_known_regex = 24 [json_name = "wellKnownRegex", (.buf.validate.predefined) = { ... }</code>
   * @return The wellKnownRegex.
   */
  build.buf.validate.KnownRegex getWellKnownRegex();

  /**
   * <pre>
   * This applies to regexes `HTTP_HEADER_NAME` and `HTTP_HEADER_VALUE` to
   * enable strict header validation. By default, this is true, and HTTP header
   * validations are [RFC-compliant](https://datatracker.ietf.org/doc/html/rfc7230#section-3). Setting to false will enable looser
   * validations that only disallow `&#92;r&#92;n&#92;0` characters, which can be used to
   * bypass header matching rules.
   *
   * ```proto
   * message MyString {
   * // The field `value` must have be a valid HTTP headers, but not enforced with strict rules.
   * string value = 1 [(buf.validate.field).string.strict = false];
   * }
   * ```
   * </pre>
   *
   * <code>optional bool strict = 25 [json_name = "strict"];</code>
   * @return Whether the strict field is set.
   */
  boolean hasStrict();
  /**
   * <pre>
   * This applies to regexes `HTTP_HEADER_NAME` and `HTTP_HEADER_VALUE` to
   * enable strict header validation. By default, this is true, and HTTP header
   * validations are [RFC-compliant](https://datatracker.ietf.org/doc/html/rfc7230#section-3). Setting to false will enable looser
   * validations that only disallow `&#92;r&#92;n&#92;0` characters, which can be used to
   * bypass header matching rules.
   *
   * ```proto
   * message MyString {
   * // The field `value` must have be a valid HTTP headers, but not enforced with strict rules.
   * string value = 1 [(buf.validate.field).string.strict = false];
   * }
   * ```
   * </pre>
   *
   * <code>optional bool strict = 25 [json_name = "strict"];</code>
   * @return The strict.
   */
  boolean getStrict();

  /**
   * <pre>
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * message MyString {
   * string value = 1 [
   * (buf.validate.field).string.example = "hello",
   * (buf.validate.field).string.example = "world"
   * ];
   * }
   * ```
   * </pre>
   *
   * <code>repeated string example = 34 [json_name = "example", (.buf.validate.predefined) = { ... }</code>
   * @return A list containing the example.
   */
  java.util.List<java.lang.String>
      getExampleList();
  /**
   * <pre>
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * message MyString {
   * string value = 1 [
   * (buf.validate.field).string.example = "hello",
   * (buf.validate.field).string.example = "world"
   * ];
   * }
   * ```
   * </pre>
   *
   * <code>repeated string example = 34 [json_name = "example", (.buf.validate.predefined) = { ... }</code>
   * @return The count of example.
   */
  int getExampleCount();
  /**
   * <pre>
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * message MyString {
   * string value = 1 [
   * (buf.validate.field).string.example = "hello",
   * (buf.validate.field).string.example = "world"
   * ];
   * }
   * ```
   * </pre>
   *
   * <code>repeated string example = 34 [json_name = "example", (.buf.validate.predefined) = { ... }</code>
   * @param index The index of the element to return.
   * @return The example at the given index.
   */
  java.lang.String getExample(int index);
  /**
   * <pre>
   * `example` specifies values that the field may have. These values SHOULD
   * conform to other rules. `example` values will not impact validation
   * but may be used as helpful guidance on how to populate the given field.
   *
   * ```proto
   * message MyString {
   * string value = 1 [
   * (buf.validate.field).string.example = "hello",
   * (buf.validate.field).string.example = "world"
   * ];
   * }
   * ```
   * </pre>
   *
   * <code>repeated string example = 34 [json_name = "example", (.buf.validate.predefined) = { ... }</code>
   * @param index The index of the value to return.
   * @return The bytes of the example at the given index.
   */
  com.google.protobuf.ByteString
      getExampleBytes(int index);

  build.buf.validate.StringRules.WellKnownCase getWellKnownCase();
}
